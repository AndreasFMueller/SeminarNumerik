# -*- coding: utf-8 -*-
"""
Created on Tue Apr  7 12:32:49 2020

@author: Tom
"""

import numpy as np
import matplotlib.pyplot as plt
import scipy.integrate as sp

#######################Hilfsfunktionen zum Plotten###################
######################################################################
def split_posneg(x,y):
    '''Splits the values of two arrays (x and y) in its positive and negative subparts.
    Returns 4 values: (x_pos, y_pos, x_neg, y_neg'''
    if len(x) != len(y):
        raise ValueError("len(x) != len(y)")

    all_r = list(zip(x,y))
    r_pos = [r for r in all_r if r[1] >= 0]
    r_neg = [r for r in all_r if r[1] < 0]

    x_pos, y_pos = zip(*r_pos)
    x_neg, y_neg = zip(*r_neg)
    
    return (x_pos, y_pos, x_neg, y_neg)

def plot_nicely(x,y, color, label):
    '''Plots x and y with a line where positive, and dottet where negative.
    Make sure you have a plt instance ready.'''
    x_pos, y_pos, x_neg, y_neg = split_posneg(x, y)
    plt.plot(x_pos, y_pos, color+'-', label=label)
    plt.plot(x_neg, y_neg, color+'--')
    
def plot_error(x_expct, y_expct, x_actual, y_actual, color, label, t=range(26)):
    '''Inputs:
    t for a time range.
    x_ and y_expect: Coordinates taht you expect, for example generated by the simulator, for each time in t
    x and y: Coordinates you calculated, for example by some AnnÃ¤hrerung.
    
    This function then calculates the euclidean distance from the expected x to the actual x and prints it.
    Make sure you have a plt instance ready.'''
    x_expct = np.array(x_expct)
    y_expct = np.array(y_expct)
    x_actual = np.array(x_actual)
    y_actual = np.array(y_actual)
    x_diff = np.abs(x_expct - x_actual)
    y_diff = np.abs(y_expct - y_actual)
    r_diff = np.sqrt(x_diff**2 + y_diff**2)
    plt.plot(t, r_diff, color, label=label)