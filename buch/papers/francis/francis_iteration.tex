\section{Francis Iteration erster Ordnung\label{francis:section:francis_iteration}}
\rhead{Francis Iteration erster Ordnung}

Nun wollen wir uns mit dem eigentlichen Francis Algorithmus \cite{francis:watkins_book} befassen.
Die Ausgangssituation für den Algorithmus ist eine Matrix, welche sich in oberer Hessenberg Form oder sogar tridiagonaler Form befindet.
Es handelt sich dabei um ein iteratives Verfahren und lässt sich daher am besten durch die Analyse einer Iteration bescheiben.

Der Algorithmus beginnt mit der Wahl eines Shifts $\rho_{1}$ und der Berechnung der ersten Kolonne von $A-\rho I$. 
Diese hat die Form:

\begin{equation}
	p=\begin{bmatrix}
	a_{11}-\rho_{1}\\
	a_{21}\\
	0\\
	.\\
	.\\
	0
	\end{bmatrix}
\end{equation}

Anschliessend muss eine Matrix $Q_{0}$ gefunden werden, welche auf den Achsen 1 und 2 arbeitet und den Wert von $a_{21}$ eliminiert. Diese kann zum Beispiel mit Givens Rotationsmatrizen \ref{francis:section:grundlagen:givens} oder einer Householder-Transformationsmatrix \ref{francis:section:grundlagen:householder} gebildet werden.

\begin{equation}
	Q_{0}^{-1}p=\begin{bmatrix}
	*\\
	0\\
	0\\
	.\\
	.\\
	0
	\end{bmatrix}
\end{equation}

Danach muss mit $Q_{0}$ A zu  $Q_{0}^{-1}AQ_{0}$ transformiert werden.
Die Transformation von A nach $Q_{0}^{-1}A$ kombiniert lediglich die Zeilen 1 und 2, die Matrix behält aber seine Hessenberg Form.
Die anschliessende Transformation von $Q_{0}^{-1}A$ nach $Q_{0}^{-1}AQ_{0}$ kombiniert die Spalten 1 und 2 wodurch die Hessenberg Form zerstört wird.
Es entsteht an der Stelle (3,1) eine "Ausbuchtung".
Der Rest der Iteration beschäftigt sich damit, die Matrix wieder in seine Hessenberg Form zu bringen.
Dafür wählen wir eine Matrix welche auf den Achsen 2 und 3 arbeitet und den Wert von $a_{31}$ eliminiert.
So wird die Ausbuchtung nach unten verschoben.
Dieses Prozedere wird wiederholt, bis die Ausbuchtung schlussendlich unten aus der Matrix hinausgeschoben wird.
Die Hessenberg Form ist wiederhergestellt.

Bei einer 5x5 Matrix als Beispiel sieht eine Iteration also wie folgt aus:

\begin{equation}
	\begin{bmatrix}
	* & * & * & * & *  \\
	* & * & *  & * & *  \\
	+ & * & * & * & *\\
	&   & * & * & * \\
	&   &   & * & * 
	\end{bmatrix}
	\begin{bmatrix}
	* & * & * & * & *  \\
	* & * & *  & * & *  \\
	& * & * & * & *\\
	&  + & * & * & * \\
	&   &   & * & * 
	\end{bmatrix}
	\begin{bmatrix}
	* & * & * & * & *  \\
	* & * & *  & * & *  \\
	& * & * & * & *\\
	&   & * & * & * \\
	&   &  + & * & * 
	\end{bmatrix}
	\begin{bmatrix}
	* & * & * & * & *  \\
	* & * & *  & * & *  \\
	& * & * & * & *\\
	&   & * & * & * \\
	&   &   & * & * 
	\end{bmatrix}
\end{equation}

Mit $\hat{A}$ als Resultat einer Francis Iteration ergibt sich: $\hat{A}=Q_{n-2}...Q_{1}Q_{0}AQ_{0}Q_{1}...Q_{n-2}$
Wobei $Q_{0}$ die Transformation bezeichnet, welche eine Ausbuchtung in der Matrix erzeugt und $Q_{1},...,Q_{n-2}$ die Transformationen sind, welche die Hessenberg Form wiederherstellen.
Dabei handelt es sich also nur um Ähnlichkeitstransformationen und $\hat{A}$ besitzt dementsprechend die gleichen Eigenwerte wie A.
Mit jeder Iteration konvergieren die Elemente unter der Diagonalen gegen null und die Eigenwerte erscheinen dementsprechend auf der Diagonalen von $\hat{A}$.

\subsection{Wahl der Shifts\label{francis:section:francis_iteration:wahl_shift}}
Die Shifts werden zur Konvergenzbeschleunigung gebraucht.
Die Wahl eines guten Shifts kann den Algorithmus drastisch beschleunigen. 
Ein guter Shift ist dabei einer, welcher einen Eigenwert der Matrix gut approximiert.
Oft wird als Shift das Matrixelement unten rechts der aktuellen Iteration gewählt.
Dieser Shift ist als Rayleigh-Quotienten-Shift bekannt.
Eine andere Shift-Strategie ist der nach James Hardy Wilkinson benannte Wilkonson-Shift.
Für diesen wird der näher am letzten Matrixelement liegende Eigenwert der untersten \glqq 2x2 Matrix \grqq als Shift benutzt.